import MCPWorkflowDiagram from '@/app/components/MCPWorkflowDiagram';
import BenefitsComparison from '@/app/components/BenefitsComparison';

export const metadata = {
  title: 'Code Execution vá»›i MCP - Giáº£i PhÃ¡p Cho Token Overhead cá»§a AI Agents',
  description: 'KhÃ¡m phÃ¡ cÃ¡ch Code Execution vá»›i MCP giáº£m 98.7% token usage, tá»« 150,000 xuá»‘ng 2,000 tokens cho complex workflows.',
  date: '2025-11-09',
};

# Code Execution vá»›i MCP: Giáº£i PhÃ¡p Cho Token Overhead cá»§a AI Agents

<div className="text-gray-600 dark:text-gray-400 mb-8">
  ğŸ“… November 9, 2025 â€¢ â±ï¸ 15 phÃºt Ä‘á»c
</div>

---

## ğŸ¯ Váº¥n Äá» Lá»›n: Token Overhead

Khi xÃ¢y dá»±ng AI agents, chÃºng ta Ä‘ang nÃ³i vá» **150,000+ tokens** cho cÃ¡c complex workflows.

Agent cá»§a báº¡n pháº£i:
- Load **má»i** tool definition ngay tá»« Ä‘áº§u
- Pass intermediate results qua láº¡i through context window
- Giá»¯ táº¥t cáº£ trong memory ngay cáº£ khi khÃ´ng dÃ¹ng Ä‘áº¿n

Äiá»u nÃ y táº¡o ra **3 headaches khá»•ng lá»“**:

### ğŸ’¸ 1. Cost
Nhá»¯ng tokens nÃ y tÄƒng ráº¥t nhanh. Running complex agent workflows trá»Ÿ nÃªn Ä‘áº¯t Ä‘á», Ä‘áº·c biá»‡t lÃ  at scale.

### ğŸŒ 2. Latency
Nhiá»u tokens = pháº£n há»“i cháº­m hÆ¡n. Agent cá»§a báº¡n tá»‘n thá»i gian process thÃ´ng tin mÃ  cÃ³ thá»ƒ khÃ´ng cáº§n.

### ğŸš« 3. Tool Limitations
Báº¡n hit context window limits ráº¥t nhanh, nghÄ©a lÃ  khÃ´ng thá»ƒ cho agent truy cáº­p nhiá»u tools nhÆ° mong muá»‘n.

---

## ğŸ’¡ Quick Solution

**Anthropic** Ä‘Ã£ tÃ¬m ra Ä‘iá»u gÃ¬ Ä‘Ã³ innovative.

Thay vÃ¬ agent call tools qua traditional method, báº¡n **treat MCP servers as code APIs**. Agent cá»§a báº¡n viáº¿t code Ä‘á»ƒ tÆ°Æ¡ng tÃ¡c vá»›i tools, thay vÃ¬ making direct tool calls cho má»—i action.

Káº¿t quáº£: Workflows trÆ°á»›c Ä‘Ã¢y consume **150,000 tokens** giá» chá»‰ dÃ¹ng **2,000 tokens**.

<div className="bg-green-100 dark:bg-green-900 p-6 rounded-lg my-6 border-l-4 border-green-500">
  <div className="text-3xl font-bold text-green-700 dark:text-green-300 mb-2">
    98.7% Token Reduction! ğŸ‰
  </div>
  <p className="text-green-800 dark:text-green-200">
    Tá»« 150,000 tokens â†’ 2,000 tokens
  </p>
</div>

---

## ğŸ” Deep Dive: Váº¥n Äá» Vá»›i Traditional Tool Calling

### Token Overhead Nightmare

Vá»›i direct tool calling, **má»i** tool definition Ä‘Æ°á»£c load vÃ o context window cá»§a agent ngay tá»« Ä‘áº§u.

TrÆ°á»›c khi agent cá»§a báº¡n thá»±c hiá»‡n báº¥t ká»³ action nÃ o, chÃºng cáº§n nháº­n biáº¿t má»i tool cÃ³ sáºµn.

Giá»‘ng nhÆ° Ä‘Æ°a cho ai Ä‘Ã³ cuá»‘n sá»• tay hÆ°á»›ng dáº«n 500 trang trÆ°á»›c khi há» cÃ³ thá»ƒ gá»i Ä‘iá»‡n thoáº¡i Ä‘Æ¡n giáº£n.

Má»—i tool definition bao gá»“m:
- Tool lÃ m gÃ¬
- Parameters nÃ o nÃ³ nháº­n
- Format nÃ o nÃ³ mong Ä‘á»£i  
- NÃ³ tráº£ vá» gÃ¬

NhÃ¢n vá»›i 50, 100, hay 200 tools, vÃ  báº¡n Ä‘ang nhÃ¬n vÃ o massive token consumption trÆ°á»›c khi agent báº¯t Ä‘áº§u lÃ m viá»‡c.

### Intermediate Results Problem

Má»—i khi agent cá»§a báº¡n calls má»™t tool, káº¿t quáº£ quay láº¡i through context window.

Náº¿u agent cáº§n chain nhiá»u tool calls láº¡i vá»›i nhau, má»—i intermediate result thÃªm nhiá»u tokens hÆ¡n.

<MCPWorkflowDiagram />

**Agent calls Tool A** â†’ Result flows through context â†’ Agent processes â†’ **Calls Tool B** â†’ Another result through context â†’ Agent processes â†’ **Calls Tool C**...

Báº¡n tháº¥y váº¥n Ä‘á» rá»“i Ä‘áº¥y.

Vá»›i complex workflows cáº§n 10, 20, hay 30 tool calls, báº¡n Ä‘ang passing massive amounts of data qua láº¡i through context window.

---

## âœ… Solution: Code Execution vá»›i MCP

<div className="bg-blue-50 dark:bg-blue-900 p-6 rounded-lg my-6">
  <h3 className="text-xl font-bold mb-3">ğŸ’­ Ã TÆ°á»Ÿng ChÃ­nh</h3>
  <p className="mb-2">
    Thay vÃ¬ agent call tools directly, nÃ³ <strong>viáº¿t code</strong> Ä‘á»ƒ tÆ°Æ¡ng tÃ¡c vá»›i MCP servers.
  </p>
  <p>
    MCP servers trá»Ÿ thÃ nh <strong>code APIs</strong> - modules mÃ  agent cÃ³ thá»ƒ import vÃ  dÃ¹ng programmatically.
  </p>
</div>

### So SÃ¡nh 2 Approaches

**Current approach:**
```
Agent uses tool calling API 
  â†’ Model loads all tool definitions 
  â†’ Model calls tools directly 
  â†’ Results come back through context
```

**Code execution approach:**
```
Agent writes code 
  â†’ Code imports only needed tools 
  â†’ Code executes and processes data 
  â†’ Only final results return to model
```

### VÃ­ Dá»¥ Thá»±c Táº¿

Giáº£ sá»­ agent cá»§a báº¡n cáº§n search through Salesforce records, filter results, vÃ  create summary.

#### âŒ Traditional Way (150,000 tokens):

```javascript
// Traditional approach - each step is a separate tool call

// Step 1: Search (tool call 1)
search_results = agent.call_tool("search_salesforce", {
    "query": "active accounts",
    "fields": ["name", "revenue", "status"]
})
// Returns 1000 records, all flow through context

// Step 2: Filter (tool call 2)  
filtered_results = agent.call_tool("filter_records", {
    "data": search_results,  // Passing large dataset through context
    "condition": "revenue > 1000000"
})
// Filtered data flows back through context

// Step 3: Summarize (tool call 3)
summary = agent.call_tool("create_summary", {
    "data": filtered_results  // More data through context
})
// Total: 3 separate tool calls, all intermediate data through context
```

#### âœ… Code Execution Way (2,000 tokens):

```javascript
// Code execution approach - single execution, all processing in environment

import { salesforce } from 'mcp-servers';

// Everything happens in the execution environment
async function getSalesforceSummary() {
    // Search
    const results = await salesforce.search({
        query: "active accounts",
        fields: ["name", "revenue", "status"]
    });
    // 1000 records - but they never touch the model's context
    
    // Filter (happens right here in code)
    const filtered = results.filter(record => record.revenue > 1000000);
    // Filtered to 50 records - still in execution environment
    
    // Summarize (still in code)
    const summary = {
        total_accounts: filtered.length,
        total_revenue: filtered.reduce((sum, r) => sum + r.revenue, 0),
        top_account: filtered.sort((a, b) => b.revenue - a.revenue)[0]
    };
    
    return summary;  // Only this small object goes back to the model
}
// Agent gets back just the summary - maybe 100 tokens
```

**Intermediate data khÃ´ng bao giá» touch model's context.** Táº¥t cáº£ xáº£y ra trong code execution environment.

---

<BenefitsComparison />

---

## ğŸ“ Khi NÃ o NÃªn DÃ¹ng Approach NÃ y?

Code execution vá»›i MCP cÃ³ Ã½ nghÄ©a khi báº¡n Ä‘ang building agents cáº§n:

### âœ… Access to Many Tools
Náº¿u agent cá»§a báº¡n connects tá»›i dozens of services, approach nÃ y lÃ  essential. Traditional method breaks down at scale.

### âœ… Complex Workflows
Multi-step processes vá»›i data transformation, filtering, vÃ  aggregation benefit massively tá»« in-environment processing.

### âœ… Production Applications
Náº¿u báº¡n running agents at scale vá»›i real users, cost vÃ  latency improvements pay for implementation complexity.

### âœ… Long-running Tasks
Báº¥t cá»© thá»© gÃ¬ cáº§n state persistence hoáº·c spans multiple sessions works better vá»›i code execution.

### âŒ Simple Use Cases
Vá»›i simple agents cÃ³ 3-5 tools vÃ  simple workflows, current tool calling váº«n works fine.

---

## ğŸš€ Trade-offs Cáº§n LÆ°u Ã

Approach nÃ y adds complexity:

- Báº¡n cáº§n **secure code execution environment** vá»›i proper sandboxing
- **Resource limits** vÃ  monitoring
- Setup cost ban Ä‘áº§u cao hÆ¡n

**NhÆ°ng** vá»›i production AI applications cáº§n scale, benefits far outweigh setup cost:

âœ… Cheaper operations  
âœ… Faster responses  
âœ… Ability to connect agent to hundreds of tools  
âœ… No context limits  

---

## ğŸ“Š Impact Metrics

<div className="grid grid-cols-1 md:grid-cols-3 gap-4 my-8">
  <div className="bg-gradient-to-br from-green-400 to-emerald-600 text-white p-6 rounded-lg text-center">
    <div className="text-4xl font-bold mb-2">98.7%</div>
    <div className="text-sm">Token Reduction</div>
  </div>
  <div className="bg-gradient-to-br from-blue-400 to-cyan-600 text-white p-6 rounded-lg text-center">
    <div className="text-4xl font-bold mb-2">75Ã—</div>
    <div className="text-sm">Faster Execution</div>
  </div>
  <div className="bg-gradient-to-br from-purple-400 to-pink-600 text-white p-6 rounded-lg text-center">
    <div className="text-4xl font-bold mb-2">âˆ</div>
    <div className="text-sm">Tools Supported</div>
  </div>
</div>

---

## ğŸ’­ Final Thoughts

Approach nÃ y **changes the economics** cá»§a building AI agents.

Token savings khÃ´ng pháº£i lÃ  lá»£i Ã­ch duy nháº¥t - má»i thá»© runs faster vÃ¬ báº¡n executing code thay vÃ¬ chaining tool calls.

Agent cá»§a báº¡n cÃ³ thá»ƒ dÃ¹ng loops, conditionals, vÃ  error handling vá»›i native code constructs thay vÃ¬ making sequential API calls.

Äá»ƒ implement approach nÃ y, báº¯t Ä‘áº§u báº±ng viá»‡c hiá»ƒu **MCP (Model Context Protocol)**. 

<div className="bg-yellow-50 dark:bg-yellow-900 p-6 rounded-lg my-6 border-l-4 border-yellow-500">
  <h3 className="text-lg font-bold mb-2">ğŸ¯ Next Steps</h3>
  <ul className="list-disc list-inside space-y-2">
    <li>NghiÃªn cá»©u Model Context Protocol</li>
    <li>Setup code execution environment</li>
    <li>Convert existing tool calls sang code-based approach</li>
    <li>Monitor token usage vÃ  performance improvements</li>
    <li>Scale dáº§n dáº§n vá»›i nhiá»u tools hÆ¡n</li>
  </ul>
</div>

---

## ğŸ”— Resources

- [Anthropic MCP Documentation](https://docs.anthropic.com/mcp)
- [MCP Specification](https://modelcontextprotocol.io)
- [GitHub - MCP Servers](https://github.com/modelcontextprotocol/servers)

---

<div className="border-t border-gray-200 dark:border-gray-700 pt-8 mt-12">
  <p className="text-center text-gray-600 dark:text-gray-400">
    ğŸ’¡ CÃ³ cÃ¢u há»i hoáº·c feedback? HÃ£y Ä‘á»ƒ láº¡i comment bÃªn dÆ°á»›i!
  </p>
</div>

